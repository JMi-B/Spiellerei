[[2025-11-06]] <-> [[2025-11-10]]

| Zeit  | Termin      |
| ----- | ----------- |
| 7:45  | Kommen      |
|       |             |
| 13:00 | Joint Daily |
| 13:15 | Azubi Daily |
|       |             |
|       | Gehen       |
- [ ] Georg nach Plan für nächste Woche fragen
- [ ] Texte in mein Projekt
- [ ] Wie soll mein Workfow aussehen für 
	- [ ] Berichtsheft
	- [ ] Prüfungsvorbereitung
	- [ ] Projektarbeit
- [ ] Obsidian verbessern
	- [ ] Tamplate für Tagesseite
	- [ ] Aufgaben mit Terminen versehen
		- [ ] Kanbanbord
		- [ ] Als Tagebuch schreiben
			- [ ] Thematisch Ablegen
# [[JMi Datenbank Projekt toDo's]]
## [[2025-11-06#Texte für mein Projekt]]
#dbmodel #pdf2Text 
### Namensregeln
In der DAtenbank benutze ich CamelCase für Tabellen und Collums. ID steht am Ende und sind zwei Großbuchstaben.
Funktionsnamen sind auch CamelCase und sprechen
Variablen
IDs werden mit  `_id` angesprochen
Variablen sollen auch hierachie abbilden.
Plural, Singular
Global - Abhänige Funktionen - Spezielle Funktionen
Im Code sichtbar machen, das ein ganz spezielles Objekt behandelt wird.
Roten Faden entwickeln 
Funktionen aus Liberys behalten ihre Namen

### 1. Pdf Verarbeitung
#pdf2Text 
Pdf umwandel und Textspeichern
Vorlagen C:\Users\juliane.bonenkamp\HandArbeitenAnleitungenDB\scripts\JMiDB_funktion_pdf_bild_text_db_del.py
C:\Users\juliane.bonenkamp\src\JMiArbeit\test03.py
- [x] Text erstellen
- [ ] Text zwischenspeichern
- das geht mit der python eigenenen Funktion ``open()`` die braucht neben dem Dateinamen als zweiten parameter den 'mode'.
	- r für read
	- a fürappand
	- w write
	- x Create 
		- zusätzlich t für text
`` with open("filename.txt", "w") as f:
	 ``f.write("überschreibt")
- [ ] Funktion zum speichern basteln
	- [ ] Dateiname und Pfad
		- [ ] Pfad wo die jpg stehen
		- [ ] gleicher Name wie die jpg nur ohne Nummer
	- [ ] In die Datei soll der Inhalt der Variabel ``text_ganz
- [ ] Wenn der Text gespeichert ist, können die jpg weg
# SQL Übungen
#sql #selct #join 
1. Gib eine Liste aller Patienten aus, die Medikamente erhalten. Die Liste soll Vorname und Name des Patienten enthalten, sowie das verschriebene Medikament und die Dosierung.
	1. Funktioniert ohne Join aus allen 3 Tabellen werden Werte abgefragt
	`SELECT p.first_name, p.last_name, m.name, pm.dosage_ml
	``from patients p, medications m, patient_medications pm
	``WHERE p.patient_id = pm.patient_id AND m.drug_id = pm.drug_id;`
	
2. Gib eine Liste aller Patienten aus und ihrer Medikamente aus. Wenn Patienten keine Medikamente erhalten, sollen sie ebenfalls in der Liste aufgeführt werden. (LEFT JOIN)
	1. Ich muss die Tabellenfelder definieren in dem ich die Tabelle definiere. Das mache ich in `from` oder in einem `join`. Wenn ich mehre `join` mit einander verknüpfe entsteht eine Herachie der Tabellen. Erste von der die zweite abhängt, dann die dritte die von der zweiten abhängt.
	``SELECT patients.first_name, patients.last_name, medications.name
	``from patients 
	``LEFT JOIN patient_medications on patients.patient_id = patient_medications.patient_id
	``left join medications on patient_medications.drug_id = medications.drug_id;

3. Gib eine Liste aller Medikamente aus, und die Patienten, die sie einnehmen. (RIGHT JOIN)
	1. Wenn ich mir das grafisch vorstelle steht die pm-Tabelle in der Mitte. Sie schneidet rechts die Medikamenten Tabelle. Die will ich vollständig. Links steht die Patienten Tabelle. Ich will die Datenmenge aus der pm-Tabelle. Imzweifelsfall Ausprobieren welcher join der richtige ist. 
	``SELECT medications.name, patients.first_name, patients.last_name
	``from patient_medications
	``right join medications on patient_medications.drug_id = medications.drug_id
	``left join patients on patient_medications.patient_id = patients.patient_id;

4. Gib eine Liste aller Patienten aus, und wie viele verschiedene Medikamente sie einnehmen.
	1. Ohne `GROUP BY` wird nur die Summe aller `drug_id` ausgegeben. `LEFT JOIN` sorgt dafür, dass alle Patienten angezeigt werden. 
	``SELECT patients.first_name, patients.last_name, COUNT(patient_medications.drug_id)
	``FROM patients
	``left join patient_medications on patients.patient_id = patient_medications.patient_id
	``group by patients.patient_id;

5. Gib eine Liste aller Medikamente aus, und wieviel in Summe von diesem Medikament an Patienten verschrieben wurde (JOIN + GROUP BY)
	1. Kann noch erweitert werden um die Summe der Dosen, ak Verbrauch
	
	``SELECT medications.name, COUNT(patient_medications.patient_id) as VerschreibungAnzahl
	 ``from medications
	 ``left JOIN patient_medications on medications.drug_id = patient_medications.drug_id
	 ``GROUP BY medications.name;
6. Gib eine Liste aller Produzenten aus, und wie viele Patienten in Summe Medikamente von diesem Produzenten verschrieben haben (neuer SQL-Befehl: DISTINCT)
	1.  Wo sollte hier noch eine DISTINCT rein? 
	
	``select producers.producer_name, COUNT(patient_medications.patient_id)
	``from medications
	``left JOIN producers on medications.producer_id = producers.producer_id
	``left JOIN patient_medications on medications.drug_id = patient_medications.drug_id
	``GROUP by producers.producer_name;
	2.  Durch das `DISTINCT` bei der `patient_id` wird vermieden Personen doppelt zu zählen, die mehrere Medikamente von einem Hersteller erhalten.
	``select producers.producer_name, COUNT(distinct patient_medications.patient_id)
	``from medications
	``left JOIN producers on medications.producer_id = producers.producer_id
	``left JOIN patient_medications on medications.drug_id = patient_medications.drug_id
	``GROUP by producers.producer_name;
7. Bonus: Wie hoch ist die Durchschnittsdosis, die die Patienten von einem Medikament erhalten. 
	1. Es hilft per Hand aufzuschreiben wo ich hin will. Copy und Ändern führt in die Irre
	``select medications.name, avg(patient_medications.dosage_ml)
	``from patients
	``RIGHT join patient_medications on patient_medications.patient_id = patients.patient_id
	``RIGHT JOIN medications on medications.drug_id = patient_medications.drug_id
	``GROUP by medications.name;

![[patienten.sql]]