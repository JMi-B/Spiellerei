[[2025-11-10]] <-> [[2025-11-12]]

| Zeit  | Termin |
| ----- | ------ |
| 7:45  | Kommen |
| 13:00 | Joint  |
| 13:15 | Daily  |
| 16:30 | Gehen  |
# Swyx Sql
#sql #Swyx  #sip 
Auswertung der Siplogs von gestern
## Aufgaben für CallDetailRecords:
#workflow 

1. Welche OriginationNumber hat wieviele Calls gemacht? (ohne JOINs)  #count
	1. Annährung ganze Spalten
	  ``select CallId, OriginationNumber from CallDetailRecords 
	2. Einzelne Rufnummern
	  ``select distinct OriginationNumber from CallDetailRecords
	3. Lösung: CallIds in Gruppe zusammen gefasst 
		``select count(CallId) as AnzahlRufe, OriginationNumber from CallDetailRecords group by OriginationNumber
		1. Ergebnis
		AnzahlRufe	OriginationNumber
		148	sip:TestUser307@127.0.0.2:5080
		150	sip:TestUser309@127.0.0.2:5080
		158	sip:TestUser305@127.0.0.2:5080
		153	sip:TestUser308@127.0.0.2:5080
		155	sip:TestUser300@127.0.0.2:5080
		156	sip:TestUser303@127.0.0.2:5080
		155	sip:TestUser304@127.0.0.2:5080
		138	sip:TestUser301@127.0.0.2:5080
		149	sip:TestUser306@127.0.0.2:5080
		158	sip:TestUser302@127.0.0.2:5080
		
2. Welche OriginationNumber hat wieviele Calls gemacht, was war die durchschnittliche Anrufezeit, und was war die gesamte Anrufzeit? (Zerlegen von StartTime und EndTime mit DATEPART)  #datepart
	1. Spalten raussuchen
		``select CallId, OriginationNumber, StartTime, EndTime from CallDetailRecords 
	2. mit `DATEPART` die Sekunden nur die Sekunden anzeigen
		``select CallId, OriginationNumber, DATEPART (s,StartTime), DATEPART (s,EndTime) from CallDetailRecords
		1. `DATAPART` teilt ein Datum in Intervalle auf und gibt eine int aus. ``YYYY/MM/DD hh:nn:ss`` Woche, Quartal ect sind auch möglich
	3. Berechnung der Anrufdauer. Im `SELECT` kann ich mehrere Operationen mit Klammern ineinander schachteln.
		``select CallId, OriginationNumber, DATEPART (s,StartTime), DATEPART (s,EndTime), Datepart (s, (EndTime - StartTime)) as AnrufDauer from CallDetailRecords
	4. Zusammenfassung  der Werte mit `COUNT`, `AVG`, `SUM` und `GROUP`
		`select count(CallId), OriginationNumber,`
		`AVG(Datepart (s, (EndTime - StartTime))) as AnrufDauerDurchschnitt, SUM(Datepart (s, (EndTime - StartTime))) as AnrufDauerSumme from CallDetailRecords group by OriginationNumber`
		AnzahlAnrufe	OriginationNumber	AnrufDauerDurchschnitt	AnrufDauerSumme
		148	sip:TestUser307@127.0.0.2:5080	32	4871
		150	sip:TestUser309@127.0.0.2:5080	31	4754
		158	sip:TestUser305@127.0.0.2:5080	29	4681
		153	sip:TestUser308@127.0.0.2:5080	31	4748
		155	sip:TestUser300@127.0.0.2:5080	29	4570
		156	sip:TestUser303@127.0.0.2:5080	31	4863
		155	sip:TestUser304@127.0.0.2:5080	30	4743
		138	sip:TestUser301@127.0.0.2:5080	34	4702
		149	sip:TestUser306@127.0.0.2:5080	31	4755
		158	sip:TestUser302@127.0.0.2:5080	29	4683
		1. Das Query kann nur Werte enthalten, die auch in den Funktionen verwendet werden. Deshalb fallen `StartTime, EndTime` als einzelne Spalten weg. Ich kann entweder `row` einzeln anzeigen oder zusammenfassen. 
	5. Lösung von Georg, die die Minuten mit einbezieht
		`SELECT OriginationNumber,`  
     `AVG((DATEPART(MINUTE, EndTime) * 60 + DATEPART(SECOND, EndTime)) - (DATEPART(MINUTE, StartTime) * 60 + DATEPART(SECOND, StartTime))) AS AvgCallDuration,`  
     `SUM((DATEPART(MINUTE, EndTime) * 60 + DATEPART(SECOND, EndTime)) - (DATEPART(MINUTE, StartTime) * 60 + DATEPART(SECOND, StartTime))) AS TotalCallDuration,`  
     `COUNT(EndTime) as NumCalls`  
		`FROM [IpPbx].[dbo].[CallDetailRecords]`  
		`GROUP BY OriginationNumber`  
		`ORDER BY TotalCallDuration DESC`
3. Was sind die Namen und Rufnummern der User, die bei Anrufen involviert waren? (JOINs mit Users- und InternalNumbers-Tabellen) #join UserID dazu
	1. Tabellen und Spalten um die Scharniere zu finden.
		`select UserID, Name FROM Users
		`select UserID,Number FROM InternalNumbers
		`select CallID, CalledNumber FROM CallDetailRecords
	2. Ein `JOIN` um über die `UserID` die Tabellen `Users` und `InternelNumbers` zu verbinden.
		`select Users.UserID, Users.Name, InternalNumbers.Number
		`FROM Users JOIN InternalNumbers
		`ON Users.UserID = InternalNumbers.UserID`
	3. Zwei `JOIN` kombinieren um die Von der `UserID` zur `CalledNumber` zu gelangen.  Die Tabelle `InternalNumbers` ist das Scharnier.
	  `select Users.UserID, Users.Name, CallDetailRecords.CalledNumber  
	  `FROM Users
	  `JOIN InternalNumbers on Users.UserID = InternalNumbers.UserID
	  `JOIN CallDetailRecords on 
	   `InternalNumbers.Number = CallDetailRecords.CalledNumber
	4. Beim gruppieren alle Werte angeben, die in die Gruppe sollen. Sonst stehen ungruppierte und gruppiert Werte in einem Query und die Abfrage ist ungenau formuliert. Was zu Fehler führt. `Column 'CallDetailRecords.CalledNumber' is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause.
		 #group_by So ist es richtig
		`select Users.UserID, Users.Name, CallDetailRecords.CalledNumber   
		`FROM Users `
		`JOIN InternalNumbers on Users.UserID = InternalNumbers.UserID `
		`JOIN CallDetailRecords on 
		`InternalNumbers.Number = CallDetailRecords.CalledNumber `
		`GROUP BY Users.Name, Users.UserID, CallDetailRecords.CalledNumber`
  


## Schritte
1. VM (Virtuelle Maschiene starten)
2. log datei von gesten suchen
3. sql managment tool
	1. Aufgaben gegen die DB laufen lassen
# Views und Stored Procedures
#sql #dbtheorie
## Tabellen
Enthalten und Ordnen die Daten. Sie sind das Gerüst.
## Views
#Views funktionieren wie Tabellen. Sie führen die Daten aus verschiedenen Tabellen zusammen oder verkleinern umfangreiche Tabellen. Sie verändern die Daten nicht. Sie stellen die Daten anders dar.
- Beispiele:
	- Meine Medien Tabellen. Einer View über alle Medien würde die Suche vereinfachen. Ein Select muss nicht jede Tabelle einzeln an sprechen.
## Stored Procedures
#Stored_Procedures 
Stored_procedures sind vorprogrammierte Abfragen. Die in der Datenbank selber gespeichert werden. 
## Vor und Nachteile